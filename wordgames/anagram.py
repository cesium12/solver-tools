#! /usr/bin/env python

# anagram.py
# Copyright 2008 Ben Aisen
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above
#       copyright notice, this list of conditions and the following
#       disclaimer in the documentation and/or other materials
#       provided with the distribution.
#     * Neither the name of the Manic Sages nor the names of its
#       contributors may be used to endorse or promote products
#       derived from this software without specific prior written
#       permission.
# 
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

# TODO: add @export declarations

# This code can be run from the command line, or imported as a module.
# Better documentation is forthcoming.

import getopt
import string
import sys

# Characters to respect when generating anagrams
default_alphabet = string.ascii_lowercase

# Characters to ignore when generating anagrams
default_ignore_chars = string.whitespace + string.punctuation

# The basic structure is a table of letter frequencies indexed by the
# alphabet variable above, and generated by lettercount below:
def lettercount(word, alphabet = default_alphabet,
                ignore_chars = default_ignore_chars):
    table = [0]*len(alphabet)
    for i in word:
        if i in ignore_chars:
            continue
        table[alphabet.index(i)] += 1
    return table

# This is a "mixin" class of common functions between the "word" and
# "phrase" classes.
class AnagramTable:
    def __init__(self, alphabet = default_alphabet):
        self.alphabet = alphabet
        self.table    = [0]*len(self.alphabet)

    def matches(self, other):
        return self.table == other.table

    def contains(self, other):
        for i in xrange(0,len(self.table)):
            if self.table[i] < other.table[i]:
                return False
        return True

    def length(self):
        return sum(self.table)

# For individual words.  Just a (word, table) tuple.
class AnagramWord(AnagramTable):
    def __init__(self, word, alphabet=default_alphabet):
        self.word  = word
        self.table = lettercount(self.word.lower(),alphabet)

    def __str__(self):
        return self.word

# For phrases, built in the search function below.
class AnagramPhrase(AnagramTable):
    def __init__(self, words = [], alphabet = default_alphabet):
        self.table = [0]*len(alphabet)
        self.words = []
        for i in words:
            self.add_word(i)

    def __str__(self):
        return ' '.join(map(str,self.words))

    def add_word(self, word):
        if hasattr(word, 'matches'):
            myword = word
        else:
            myword = AnagramWord(word)
        for i in xrange(0,len(self.table)):
            self.table[i] += myword.table[i]
        self.words.append(myword)

    def plus_word(self, word):
        newphrase = AnagramPhrase()
        newphrase.words = list(self.words)
        newphrase.table = list(self.table)
        newphrase.add_word(word)
        return newphrase

# Dictionary class.
class AnagramDict:
    def __init__(self, wordlist = None):
        self.wordlist = []
        if wordlist:
            for w in wordlist:
                if hasattr(w, 'matches'):
                    self.wordlist.append(w)
                else:
                    self.wordlist.append(AnagramWord(w))

    @classmethod
    def new_from_file(cls, dictfile, min_letters = 2, max_letters = 80,
                       exclude_proper_nouns = True, 
                       alphabet = default_alphabet):
        f = open(dictfile)
        wlists = [None]*max_letters
        for line in f:
            line = line.strip()
            # XXX - debian/ubuntu /usr/dict/words has a blank line
            if line == "": continue
            try:
                if exclude_proper_nouns and line[0].isupper():
                    continue
                w = AnagramWord(line,alphabet)
                if w.length() < min_letters or w.length() > max_letters:
                    continue
                if not wlists[w.length()-1]: wlists[w.length()-1] = []
                wlists[w.length()-1].append(w)
            except ValueError:
                pass
        f.close()
        wordlist = []
        for i in xrange(max_letters,min_letters-1,-1):
            if wlists[i-1]: wordlist.extend(wlists[i-1])
        return AnagramDict(wordlist)

    # Find single-word anagrams
    def find_words(self, word):
        if not hasattr(word,'matches'):
            word = AnagramWord(word)
        for w in wordlist:
            if word.matches(w):
                yield w

    # Find anagram phrases
    def find_phrases(self, word):
        if not hasattr(word,'matches'):
            word = AnagramWord(word)
        filt_dict = self.filter(word)
        for p in filt_dict.find_phrases_recurse(word, AnagramPhrase(), 0):
            yield p
        
    def filter(self, word):
        return AnagramDict(wordlist = filter(lambda a: word.contains(a),
                                             self.wordlist))

    def find_phrases_recurse(self, word, partial, lastindex):
        for i in xrange(lastindex, len(self.wordlist)):
            w = self.wordlist[i]
            phrase = partial.plus_word(w)
            if word.matches(phrase):
                yield phrase
            elif word.contains(phrase):
                for p in self.find_phrases_recurse(word, phrase, i):
                    yield p

# TODO: replace this with proper documentation
USAGE = """Usage: anagram [options] word                       
-d file    --dictionary=file    use file as dictionary
                                (default /usr/share/dict/words)
-h         --help               print this message
           --max-letters=n      search words with <=n letters (default 80)
           --min-letters=n      search words with >=n letters (default 2)
"""
def usage():
    print USAGE
    

def main():
    dictfile = '/usr/share/dict/words'
    min_letters = 2
    max_letters = 80

    if len(sys.argv) == 1:
        print 'Usage: anagram [options] word'
        sys.exit(1)

    (optlist, args) = \
        getopt.getopt(sys.argv[1:], 'd:h',
                      ['dictionary=', 
                       'help', 
                       'max-letters=', 
                       'min-letters='])
    
    for o,a in optlist:
        if o == '-h' or o =='--help':
            usage()
            sys.exit(0)
        elif o == '-d' or o == '--dictionary':
            dictfile = a
        elif o == '--max-letters':
            max_letters = a
        elif o == '--min-letters':
            min_letters = a
        else:
            assert False, 'unhandled option '+o

    if len(args) == 0:
        print 'Usage: anagram [options] word'
        sys.exit(1)

    input_word = ' '.join(args)

    adict = AnagramDict.new_from_file(dictfile, min_letters, max_letters)
    #print 'Dictionary initialized with %d words.' % len(adict.wordlist)

    for phr in adict.find_phrases(AnagramWord(input_word)):
        print phr

if __name__ == '__main__':
    main()
